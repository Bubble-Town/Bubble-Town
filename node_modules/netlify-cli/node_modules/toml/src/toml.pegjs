{
  var nodes = [];

  function genError(err, line, col) {
    var ex = new Error(err);
    ex.line = line;
    ex.column = col;
    throw ex;
  }

  function addNode(node) {
    nodes.push(node);
  }

  function node(type, value, line, column, key) {
    var obj = { type: type, value: value, line: line(), column: column() };
    if (key) obj.key = key;
    return obj;
  }

  function convertCodePoint(str, line, col) {
    var num = parseInt("0x" + str);

    if (
      !isFinite(num) ||
      Math.floor(num) != num ||
      num < 0 ||
      num > 0x10FFFF ||
      (num > 0xD7FF && num < 0xE000)
    ) {
      genError("Invalid Unicode escape code: " + str, line, col);
    } else {
      return fromCodePoint(num);
    }
  }

  function fromCodePoint() {
    var MAX_SIZE = 0x4000;
    var codeUnits = [];
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    var result = '';
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (codePoint <= 0xFFFF) { // BMP code point
        codeUnits.push(codePoint);
      } else { // Astral code point; split in surrogate halves
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
      if (index + 1 == length || codeUnits.length > MAX_SIZE) {
        result += String.fromCharCode.apply(null, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  }
}

start
  = line*                               { return nodes }

line
  = S* expr:expression S* comment* (NL+ / EOF)
  / S+ (NL+ / EOF)
  / NL

expression
  = comment / path / tablearray / assignment

comment
  = '#' (!(NL / EOF) .)*

path
  = '[' S* name:table_key S* ']'              { addNode(node('ObjectPath', name, line, column)) }

tablearray
  = '[' '[' S* name:table_key S* ']' ']'      { addNode(node('ArrayPath', name, line, column)) }

table_key
  = parts:dot_ended_table_key_part+ name:table_key_part    { return parts.concat(name) }
  / name:table_key_part                                    { return [name] }

table_key_part
  = S* name:key S*                      { return name }
  / S* name:quoted_key S*               { return name }

dot_ended_table_key_part
  = S* name:key S* '.' S*               { return name }
  / S* name:quoted_key S* '.' S*        { return name }

assignment
  = key:key S* '=' S* value:value        { addNode(node('Assign', value, line, column, key)) }
  / key:quoted_key S* '=' S* value:value { addNode(node('Assign', value, line, column, key)) }

key
  = chars:ASCII_BASIC+ { return chars.join('') }

quoted_key
  = node:double_quoted_single_line_string { return node.value }
  / node:single_quoted_single_line_string { return node.value }

value
  = string / datetime / float / integer / boolean / array / inline_table

string
  = double_quoted_mult